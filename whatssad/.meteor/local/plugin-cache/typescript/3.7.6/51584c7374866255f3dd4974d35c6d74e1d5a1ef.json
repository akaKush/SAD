{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/marc/Escritorio/ETSETB/3B/SAD/SAD/whatssad/packages/react-meteor-data/useTracker.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/react-meteor-data/useTracker.ts","filename":"/home/marc/Escritorio/ETSETB/3B/SAD/SAD/whatssad/packages/react-meteor-data/useTracker.ts","inputSourceMap":{"version":3,"file":"packages/react-meteor-data/useTracker.ts","sourceRoot":"","sources":["packages/react-meteor-data/useTracker.ts"],"names":[],"mappings":"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","sourcesContent":["declare var Package: any\nimport { Meteor } from 'meteor/meteor';\nimport { Tracker } from 'meteor/tracker';\nimport { useReducer, useEffect, useRef, useMemo } from 'react';\n\n// Warns if data is a Mongo.Cursor or a POJO containing a Mongo.Cursor.\nfunction checkCursor(data: any): void {\n  let shouldWarn = false;\n  if (Package.mongo && Package.mongo.Mongo && data && typeof data === 'object') {\n    if (data instanceof Package.mongo.Mongo.Cursor) {\n      shouldWarn = true;\n    } else if (Object.getPrototypeOf(data) === Object.prototype) {\n      Object.keys(data).forEach((key) => {\n        if (data[key] instanceof Package.mongo.Mongo.Cursor) {\n          shouldWarn = true;\n        }\n      });\n    }\n  }\n  if (shouldWarn) {\n    console.warn(\n      'Warning: your reactive function is returning a Mongo cursor. '\n      + 'This value will not be reactive. You probably want to call '\n      + '`.fetch()` on the cursor before returning it.'\n    );\n  }\n}\n\n// Used to create a forceUpdate from useReducer. Forces update by\n// incrementing a number whenever the dispatch method is invoked.\nconst fur = (x: number): number => x + 1;\nconst useForceUpdate = (): CallableFunction => {\n  const [, forceUpdate] = useReducer(fur, 0);\n  return forceUpdate;\n}\n\ntype ReactiveFn = (c?: Tracker.Computation) => any;\ntype ComputationHandler = (c: Tracker.Computation) => () => void | void;\ntype TrackerRefs = {\n  reactiveFn: ReactiveFn;\n  computationHandler?: ComputationHandler;\n  deps?: Array<any>;\n  computation?: Tracker.Computation;\n  isMounted: boolean;\n  disposeId?: ReturnType<typeof setTimeout>;\n  trackerData: any;\n  computationCleanup?: () => void;\n  trackerCount?: number\n}\n\n// The follow functions were hoisted out of the closure to reduce allocations.\n// Since they no longer have access to the local vars, we pass them in and mutate here.\nconst dispose = (refs: TrackerRefs): void => {\n  if (refs.computationCleanup) {\n    refs.computationCleanup();\n    delete refs.computationCleanup;\n  }\n  if (refs.computation) {\n    refs.computation.stop();\n    refs.computation = null;\n  }\n};\n\nconst runReactiveFn = Meteor.isDevelopment\n  ? (refs: TrackerRefs, c: Tracker.Computation): void => {\n    const data = refs.reactiveFn(c);\n    checkCursor(data);\n    refs.trackerData = data;\n  }\n  : (refs: TrackerRefs, c: Tracker.Computation): void => {\n    refs.trackerData = refs.reactiveFn(c);\n  };\n\nconst clear = (refs: TrackerRefs): void => {\n  if (refs.disposeId) {\n    clearTimeout(refs.disposeId);\n    delete refs.disposeId;\n  }\n};\n\nconst track = (refs: TrackerRefs, forceUpdate: Function, trackedFn: Function): void => {\n  // Use Tracker.nonreactive in case we are inside a Tracker Computation.\n  // This can happen if someone calls `ReactDOM.render` inside a Computation.\n  // In that case, we want to opt out of the normal behavior of nested\n  // Computations, where if the outer one is invalidated or stopped,\n  // it stops the inner one.\n  Tracker.nonreactive(() => Tracker.autorun((c: Tracker.Computation) => {\n    refs.computation = c;\n    trackedFn(c, refs, forceUpdate);\n  }));\n};\n\nconst doFirstRun = (refs: TrackerRefs, c: Tracker.Computation): void => {\n  // If there is a computationHandler, pass it the computation, and store the\n  // result, which may be a cleanup method.\n  if (refs.computationHandler) {\n    const cleanupHandler = refs.computationHandler(c);\n    if (cleanupHandler) {\n      if (Meteor.isDevelopment && typeof cleanupHandler !== 'function') {\n        console.warn(\n          'Warning: Computation handler should return a function '\n          + 'to be used for cleanup or return nothing.'\n        );\n      }\n      refs.computationCleanup = cleanupHandler;\n    }\n  }\n  // Always run the reactiveFn on firstRun\n  runReactiveFn(refs, c);\n}\n\nconst tracked = (c: Tracker.Computation, refs: TrackerRefs, forceUpdate: Function): void => {\n  if (c.firstRun) {\n    doFirstRun(refs, c);\n  } else {\n    if (refs.isMounted) {\n      // Only run the reactiveFn if the component is mounted.\n      runReactiveFn(refs, c);\n      forceUpdate();\n    } else {\n      // If we got here, then a reactive update happened before the render was\n      // committed - before useEffect has run. We don't want to run the reactiveFn\n      // while we are not sure this render will be committed, so we'll dispose of the\n      // computation, and set everything up to be restarted in useEffect if needed.\n      // NOTE: If we don't run the user's reactiveFn when a computation updates, we'll\n      // leave the computation in a non-reactive state - so we need to dispose here\n      // and let useEffect recreate the computation later.\n      dispose(refs);\n      // Might as well clear the timeout!\n      clear(refs);\n    }\n  }\n};\n\ninterface useTrackerSignature {\n  (reactiveFn: ReactiveFn, deps?: null | Array<any>, computationHandler?: ComputationHandler): any\n}\n\nconst useTrackerNoDeps: useTrackerSignature = (reactiveFn, deps = null, computationHandler) => {\n  const { current: refs } = useRef<TrackerRefs>({\n    reactiveFn,\n    isMounted: false,\n    trackerData: null\n  });\n  const forceUpdate = useForceUpdate();\n\n  refs.reactiveFn = reactiveFn;\n  if (computationHandler) {\n    refs.computationHandler = computationHandler;\n  }\n\n  // Without deps, always dispose and recreate the computation with every render.\n  dispose(refs);\n  track(refs, forceUpdate, (c: Tracker.Computation) => {\n    if (c.firstRun) {\n      doFirstRun(refs, c);\n    } else {\n      // For any reactive change, forceUpdate and let the next render rebuild the computation.\n      forceUpdate();\n    }\n  });\n\n  // To avoid creating side effects in render with Tracker when not using deps\n  // create the computation, run the user's reactive function in a computation synchronously,\n  // then immediately dispose of it. It'll be recreated again after the render is committed.\n  if (!refs.isMounted) {\n    // We want to forceUpdate in useEffect to support StrictMode.\n    // See: https://github.com/meteor/react-packages/issues/278\n    dispose(refs);\n  }\n\n  useEffect(() => {\n    // Let subsequent renders know we are mounted (render is comitted).\n    refs.isMounted = true;\n\n    // Render is committed. Since useTracker without deps always runs synchronously,\n    // forceUpdate and let the next render recreate the computation.\n    forceUpdate();\n\n    // stop the computation on unmount\n    return () => dispose(refs);\n  }, []);\n\n  return refs.trackerData;\n}\n\nconst useTrackerWithDeps: useTrackerSignature = (reactiveFn, deps: Array<any>, computationHandler) => {\n  const { current: refs } = useRef<TrackerRefs>({\n    reactiveFn,\n    isMounted: false,\n    trackerData: null\n  });\n  const forceUpdate = useForceUpdate();\n\n  // Always have up to date deps and computations in all contexts\n  refs.reactiveFn = reactiveFn;\n  refs.deps = deps;\n  if (computationHandler) {\n    refs.computationHandler = computationHandler;\n  }\n\n  // We are abusing useMemo a little bit, using it for it's deps\n  // compare, but not for it's memoization.\n  useMemo(() => {\n    // stop the old one.\n    dispose(refs);\n\n    track(refs, forceUpdate, tracked)\n\n    // Tracker creates side effect in render, which can be problematic in some cases, such as\n    // Suspense or concurrent rendering or if an error is thrown and handled by an error boundary.\n    // We still want synchronous rendering for a number of reasons (see readme). useTracker works\n    // around memory/resource leaks by setting a time out to automatically clean everything up,\n    // and watching a set of references to make sure everything is choreographed correctly.\n    if (!refs.isMounted) {\n      // Components yield to allow the DOM to update and the browser to paint before useEffect\n      // is run. In concurrent mode this can take quite a long time. 1000ms should be enough\n      // in most cases.\n      refs.disposeId = setTimeout(() => {\n        if (!refs.isMounted) {\n          dispose(refs);\n        }\n      }, 1000);\n    }\n  }, deps);\n\n  useEffect(() => {\n    refs.isMounted = true;\n\n    // Render is committed, clear the dispose timeout\n    clear(refs);\n\n    // If it took longer than 1000ms to get to useEffect, or a reactive update happened\n    // before useEffect, restart the computation and forceUpdate.\n    if (!refs.computation) {\n      // This also runs runReactiveFn\n      track(refs, forceUpdate, tracked);\n      forceUpdate();\n    }\n\n    // stop the computation on unmount\n    return () => dispose(refs);\n  }, []);\n\n  return refs.trackerData;\n}\n\nconst useTrackerClient: useTrackerSignature = (reactiveFn, deps = null, computationHandler) =>\n  (deps === null || deps === undefined || !Array.isArray(deps))\n    ? useTrackerNoDeps(reactiveFn, deps, computationHandler)\n    : useTrackerWithDeps(reactiveFn, deps, computationHandler);\n\nconst useTrackerServer: useTrackerSignature = (reactiveFn, deps = null, computationHandler) =>\n  Tracker.nonreactive(reactiveFn);\n\n// When rendering on the server, we don't want to use the Tracker.\n// We only do the first rendering on the server so we can get the data right away\nconst useTracker = Meteor.isServer\n  ? useTrackerServer\n  : useTrackerClient;\n\nconst useTrackerDev: useTrackerSignature = (reactiveFn, deps = null, computationHandler) => {\n  if (typeof reactiveFn !== 'function') {\n    console.warn(\n      'Warning: useTracker expected a function in it\\'s first argument '\n      + `(reactiveFn), but got type of ${typeof reactiveFn}.`\n    );\n  }\n  if (deps && !Array.isArray(deps)) {\n    console.warn(\n      'Warning: useTracker expected an array in it\\'s second argument '\n      + `(dependency), but got type of ${typeof deps}.`\n    );\n  }\n  if (computationHandler && typeof computationHandler !== 'function') {\n    console.warn(\n      'Warning: useTracker expected a function in it\\'s third argument'\n      + `(computationHandler), but got type of ${typeof computationHandler}.`\n    );\n  }\n  return useTracker(reactiveFn, deps, computationHandler);\n}\n\nexport default Meteor.isDevelopment\n  ? useTrackerDev\n  : useTracker;\n"]},"passPerPreset":false,"envName":"development","cwd":"/home/marc/Escritorio/ETSETB/3B/SAD/SAD/whatssad","root":"/home/marc/Escritorio/ETSETB/3B/SAD/SAD/whatssad","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.9.2","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/marc/Escritorio/ETSETB/3B/SAD/SAD/whatssad/packages/react-meteor-data/useTracker.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/react-meteor-data/useTracker.ts"}},"code":"var _slicedToArray;\n\nmodule.link(\"@babel/runtime/helpers/slicedToArray\", {\n  default: function (v) {\n    _slicedToArray = v;\n  }\n}, 0);\n\nvar _typeof;\n\nmodule.link(\"@babel/runtime/helpers/typeof\", {\n  default: function (v) {\n    _typeof = v;\n  }\n}, 1);\nvar Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 0);\nvar Tracker;\nmodule.link(\"meteor/tracker\", {\n  Tracker: function (v) {\n    Tracker = v;\n  }\n}, 1);\nvar useReducer, useEffect, useRef, useMemo;\nmodule.link(\"react\", {\n  useReducer: function (v) {\n    useReducer = v;\n  },\n  useEffect: function (v) {\n    useEffect = v;\n  },\n  useRef: function (v) {\n    useRef = v;\n  },\n  useMemo: function (v) {\n    useMemo = v;\n  }\n}, 2);\n\n// Warns if data is a Mongo.Cursor or a POJO containing a Mongo.Cursor.\nfunction checkCursor(data) {\n  var shouldWarn = false;\n\n  if (Package.mongo && Package.mongo.Mongo && data && _typeof(data) === 'object') {\n    if (data instanceof Package.mongo.Mongo.Cursor) {\n      shouldWarn = true;\n    } else if (Object.getPrototypeOf(data) === Object.prototype) {\n      Object.keys(data).forEach(function (key) {\n        if (data[key] instanceof Package.mongo.Mongo.Cursor) {\n          shouldWarn = true;\n        }\n      });\n    }\n  }\n\n  if (shouldWarn) {\n    console.warn('Warning: your reactive function is returning a Mongo cursor. ' + 'This value will not be reactive. You probably want to call ' + '`.fetch()` on the cursor before returning it.');\n  }\n} // Used to create a forceUpdate from useReducer. Forces update by\n// incrementing a number whenever the dispatch method is invoked.\n\n\nvar fur = function (x) {\n  return x + 1;\n};\n\nvar useForceUpdate = function () {\n  var _useReducer = useReducer(fur, 0),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      forceUpdate = _useReducer2[1];\n\n  return forceUpdate;\n}; // The follow functions were hoisted out of the closure to reduce allocations.\n// Since they no longer have access to the local vars, we pass them in and mutate here.\n\n\nvar dispose = function (refs) {\n  if (refs.computationCleanup) {\n    refs.computationCleanup();\n    delete refs.computationCleanup;\n  }\n\n  if (refs.computation) {\n    refs.computation.stop();\n    refs.computation = null;\n  }\n};\n\nvar runReactiveFn = Meteor.isDevelopment ? function (refs, c) {\n  var data = refs.reactiveFn(c);\n  checkCursor(data);\n  refs.trackerData = data;\n} : function (refs, c) {\n  refs.trackerData = refs.reactiveFn(c);\n};\n\nvar clear = function (refs) {\n  if (refs.disposeId) {\n    clearTimeout(refs.disposeId);\n    delete refs.disposeId;\n  }\n};\n\nvar track = function (refs, forceUpdate, trackedFn) {\n  // Use Tracker.nonreactive in case we are inside a Tracker Computation.\n  // This can happen if someone calls `ReactDOM.render` inside a Computation.\n  // In that case, we want to opt out of the normal behavior of nested\n  // Computations, where if the outer one is invalidated or stopped,\n  // it stops the inner one.\n  Tracker.nonreactive(function () {\n    return Tracker.autorun(function (c) {\n      refs.computation = c;\n      trackedFn(c, refs, forceUpdate);\n    });\n  });\n};\n\nvar doFirstRun = function (refs, c) {\n  // If there is a computationHandler, pass it the computation, and store the\n  // result, which may be a cleanup method.\n  if (refs.computationHandler) {\n    var cleanupHandler = refs.computationHandler(c);\n\n    if (cleanupHandler) {\n      if (Meteor.isDevelopment && typeof cleanupHandler !== 'function') {\n        console.warn('Warning: Computation handler should return a function ' + 'to be used for cleanup or return nothing.');\n      }\n\n      refs.computationCleanup = cleanupHandler;\n    }\n  } // Always run the reactiveFn on firstRun\n\n\n  runReactiveFn(refs, c);\n};\n\nvar tracked = function (c, refs, forceUpdate) {\n  if (c.firstRun) {\n    doFirstRun(refs, c);\n  } else {\n    if (refs.isMounted) {\n      // Only run the reactiveFn if the component is mounted.\n      runReactiveFn(refs, c);\n      forceUpdate();\n    } else {\n      // If we got here, then a reactive update happened before the render was\n      // committed - before useEffect has run. We don't want to run the reactiveFn\n      // while we are not sure this render will be committed, so we'll dispose of the\n      // computation, and set everything up to be restarted in useEffect if needed.\n      // NOTE: If we don't run the user's reactiveFn when a computation updates, we'll\n      // leave the computation in a non-reactive state - so we need to dispose here\n      // and let useEffect recreate the computation later.\n      dispose(refs); // Might as well clear the timeout!\n\n      clear(refs);\n    }\n  }\n};\n\nvar useTrackerNoDeps = function (reactiveFn) {\n  var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var computationHandler = arguments.length > 2 ? arguments[2] : undefined;\n\n  var _useRef = useRef({\n    reactiveFn: reactiveFn,\n    isMounted: false,\n    trackerData: null\n  }),\n      refs = _useRef.current;\n\n  var forceUpdate = useForceUpdate();\n  refs.reactiveFn = reactiveFn;\n\n  if (computationHandler) {\n    refs.computationHandler = computationHandler;\n  } // Without deps, always dispose and recreate the computation with every render.\n\n\n  dispose(refs);\n  track(refs, forceUpdate, function (c) {\n    if (c.firstRun) {\n      doFirstRun(refs, c);\n    } else {\n      // For any reactive change, forceUpdate and let the next render rebuild the computation.\n      forceUpdate();\n    }\n  }); // To avoid creating side effects in render with Tracker when not using deps\n  // create the computation, run the user's reactive function in a computation synchronously,\n  // then immediately dispose of it. It'll be recreated again after the render is committed.\n\n  if (!refs.isMounted) {\n    // We want to forceUpdate in useEffect to support StrictMode.\n    // See: https://github.com/meteor/react-packages/issues/278\n    dispose(refs);\n  }\n\n  useEffect(function () {\n    // Let subsequent renders know we are mounted (render is comitted).\n    refs.isMounted = true; // Render is committed. Since useTracker without deps always runs synchronously,\n    // forceUpdate and let the next render recreate the computation.\n\n    forceUpdate(); // stop the computation on unmount\n\n    return function () {\n      return dispose(refs);\n    };\n  }, []);\n  return refs.trackerData;\n};\n\nvar useTrackerWithDeps = function (reactiveFn, deps, computationHandler) {\n  var _useRef2 = useRef({\n    reactiveFn: reactiveFn,\n    isMounted: false,\n    trackerData: null\n  }),\n      refs = _useRef2.current;\n\n  var forceUpdate = useForceUpdate(); // Always have up to date deps and computations in all contexts\n\n  refs.reactiveFn = reactiveFn;\n  refs.deps = deps;\n\n  if (computationHandler) {\n    refs.computationHandler = computationHandler;\n  } // We are abusing useMemo a little bit, using it for it's deps\n  // compare, but not for it's memoization.\n\n\n  useMemo(function () {\n    // stop the old one.\n    dispose(refs);\n    track(refs, forceUpdate, tracked); // Tracker creates side effect in render, which can be problematic in some cases, such as\n    // Suspense or concurrent rendering or if an error is thrown and handled by an error boundary.\n    // We still want synchronous rendering for a number of reasons (see readme). useTracker works\n    // around memory/resource leaks by setting a time out to automatically clean everything up,\n    // and watching a set of references to make sure everything is choreographed correctly.\n\n    if (!refs.isMounted) {\n      // Components yield to allow the DOM to update and the browser to paint before useEffect\n      // is run. In concurrent mode this can take quite a long time. 1000ms should be enough\n      // in most cases.\n      refs.disposeId = setTimeout(function () {\n        if (!refs.isMounted) {\n          dispose(refs);\n        }\n      }, 1000);\n    }\n  }, deps);\n  useEffect(function () {\n    refs.isMounted = true; // Render is committed, clear the dispose timeout\n\n    clear(refs); // If it took longer than 1000ms to get to useEffect, or a reactive update happened\n    // before useEffect, restart the computation and forceUpdate.\n\n    if (!refs.computation) {\n      // This also runs runReactiveFn\n      track(refs, forceUpdate, tracked);\n      forceUpdate();\n    } // stop the computation on unmount\n\n\n    return function () {\n      return dispose(refs);\n    };\n  }, []);\n  return refs.trackerData;\n};\n\nvar useTrackerClient = function (reactiveFn) {\n  var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var computationHandler = arguments.length > 2 ? arguments[2] : undefined;\n  return deps === null || deps === undefined || !Array.isArray(deps) ? useTrackerNoDeps(reactiveFn, deps, computationHandler) : useTrackerWithDeps(reactiveFn, deps, computationHandler);\n};\n\nvar useTrackerServer = function (reactiveFn) {\n  var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var computationHandler = arguments.length > 2 ? arguments[2] : undefined;\n  return Tracker.nonreactive(reactiveFn);\n}; // When rendering on the server, we don't want to use the Tracker.\n// We only do the first rendering on the server so we can get the data right away\n\n\nvar useTracker = Meteor.isServer ? useTrackerServer : useTrackerClient;\n\nvar useTrackerDev = function (reactiveFn) {\n  var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var computationHandler = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (typeof reactiveFn !== 'function') {\n    console.warn('Warning: useTracker expected a function in it\\'s first argument ' + (\"(reactiveFn), but got type of \" + _typeof(reactiveFn) + \".\"));\n  }\n\n  if (deps && !Array.isArray(deps)) {\n    console.warn('Warning: useTracker expected an array in it\\'s second argument ' + (\"(dependency), but got type of \" + _typeof(deps) + \".\"));\n  }\n\n  if (computationHandler && typeof computationHandler !== 'function') {\n    console.warn('Warning: useTracker expected a function in it\\'s third argument' + (\"(computationHandler), but got type of \" + _typeof(computationHandler) + \".\"));\n  }\n\n  return useTracker(reactiveFn, deps, computationHandler);\n};\n\nmodule.exportDefault(Meteor.isDevelopment ? useTrackerDev : useTracker);","map":{"version":3,"sources":["packages/react-meteor-data/useTracker.ts"],"names":[],"mappings":"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","sourcesContent":["declare var Package: any\nimport { Meteor } from 'meteor/meteor';\nimport { Tracker } from 'meteor/tracker';\nimport { useReducer, useEffect, useRef, useMemo } from 'react';\n\n// Warns if data is a Mongo.Cursor or a POJO containing a Mongo.Cursor.\nfunction checkCursor(data: any): void {\n  let shouldWarn = false;\n  if (Package.mongo && Package.mongo.Mongo && data && typeof data === 'object') {\n    if (data instanceof Package.mongo.Mongo.Cursor) {\n      shouldWarn = true;\n    } else if (Object.getPrototypeOf(data) === Object.prototype) {\n      Object.keys(data).forEach((key) => {\n        if (data[key] instanceof Package.mongo.Mongo.Cursor) {\n          shouldWarn = true;\n        }\n      });\n    }\n  }\n  if (shouldWarn) {\n    console.warn(\n      'Warning: your reactive function is returning a Mongo cursor. '\n      + 'This value will not be reactive. You probably want to call '\n      + '`.fetch()` on the cursor before returning it.'\n    );\n  }\n}\n\n// Used to create a forceUpdate from useReducer. Forces update by\n// incrementing a number whenever the dispatch method is invoked.\nconst fur = (x: number): number => x + 1;\nconst useForceUpdate = (): CallableFunction => {\n  const [, forceUpdate] = useReducer(fur, 0);\n  return forceUpdate;\n}\n\ntype ReactiveFn = (c?: Tracker.Computation) => any;\ntype ComputationHandler = (c: Tracker.Computation) => () => void | void;\ntype TrackerRefs = {\n  reactiveFn: ReactiveFn;\n  computationHandler?: ComputationHandler;\n  deps?: Array<any>;\n  computation?: Tracker.Computation;\n  isMounted: boolean;\n  disposeId?: ReturnType<typeof setTimeout>;\n  trackerData: any;\n  computationCleanup?: () => void;\n  trackerCount?: number\n}\n\n// The follow functions were hoisted out of the closure to reduce allocations.\n// Since they no longer have access to the local vars, we pass them in and mutate here.\nconst dispose = (refs: TrackerRefs): void => {\n  if (refs.computationCleanup) {\n    refs.computationCleanup();\n    delete refs.computationCleanup;\n  }\n  if (refs.computation) {\n    refs.computation.stop();\n    refs.computation = null;\n  }\n};\n\nconst runReactiveFn = Meteor.isDevelopment\n  ? (refs: TrackerRefs, c: Tracker.Computation): void => {\n    const data = refs.reactiveFn(c);\n    checkCursor(data);\n    refs.trackerData = data;\n  }\n  : (refs: TrackerRefs, c: Tracker.Computation): void => {\n    refs.trackerData = refs.reactiveFn(c);\n  };\n\nconst clear = (refs: TrackerRefs): void => {\n  if (refs.disposeId) {\n    clearTimeout(refs.disposeId);\n    delete refs.disposeId;\n  }\n};\n\nconst track = (refs: TrackerRefs, forceUpdate: Function, trackedFn: Function): void => {\n  // Use Tracker.nonreactive in case we are inside a Tracker Computation.\n  // This can happen if someone calls `ReactDOM.render` inside a Computation.\n  // In that case, we want to opt out of the normal behavior of nested\n  // Computations, where if the outer one is invalidated or stopped,\n  // it stops the inner one.\n  Tracker.nonreactive(() => Tracker.autorun((c: Tracker.Computation) => {\n    refs.computation = c;\n    trackedFn(c, refs, forceUpdate);\n  }));\n};\n\nconst doFirstRun = (refs: TrackerRefs, c: Tracker.Computation): void => {\n  // If there is a computationHandler, pass it the computation, and store the\n  // result, which may be a cleanup method.\n  if (refs.computationHandler) {\n    const cleanupHandler = refs.computationHandler(c);\n    if (cleanupHandler) {\n      if (Meteor.isDevelopment && typeof cleanupHandler !== 'function') {\n        console.warn(\n          'Warning: Computation handler should return a function '\n          + 'to be used for cleanup or return nothing.'\n        );\n      }\n      refs.computationCleanup = cleanupHandler;\n    }\n  }\n  // Always run the reactiveFn on firstRun\n  runReactiveFn(refs, c);\n}\n\nconst tracked = (c: Tracker.Computation, refs: TrackerRefs, forceUpdate: Function): void => {\n  if (c.firstRun) {\n    doFirstRun(refs, c);\n  } else {\n    if (refs.isMounted) {\n      // Only run the reactiveFn if the component is mounted.\n      runReactiveFn(refs, c);\n      forceUpdate();\n    } else {\n      // If we got here, then a reactive update happened before the render was\n      // committed - before useEffect has run. We don't want to run the reactiveFn\n      // while we are not sure this render will be committed, so we'll dispose of the\n      // computation, and set everything up to be restarted in useEffect if needed.\n      // NOTE: If we don't run the user's reactiveFn when a computation updates, we'll\n      // leave the computation in a non-reactive state - so we need to dispose here\n      // and let useEffect recreate the computation later.\n      dispose(refs);\n      // Might as well clear the timeout!\n      clear(refs);\n    }\n  }\n};\n\ninterface useTrackerSignature {\n  (reactiveFn: ReactiveFn, deps?: null | Array<any>, computationHandler?: ComputationHandler): any\n}\n\nconst useTrackerNoDeps: useTrackerSignature = (reactiveFn, deps = null, computationHandler) => {\n  const { current: refs } = useRef<TrackerRefs>({\n    reactiveFn,\n    isMounted: false,\n    trackerData: null\n  });\n  const forceUpdate = useForceUpdate();\n\n  refs.reactiveFn = reactiveFn;\n  if (computationHandler) {\n    refs.computationHandler = computationHandler;\n  }\n\n  // Without deps, always dispose and recreate the computation with every render.\n  dispose(refs);\n  track(refs, forceUpdate, (c: Tracker.Computation) => {\n    if (c.firstRun) {\n      doFirstRun(refs, c);\n    } else {\n      // For any reactive change, forceUpdate and let the next render rebuild the computation.\n      forceUpdate();\n    }\n  });\n\n  // To avoid creating side effects in render with Tracker when not using deps\n  // create the computation, run the user's reactive function in a computation synchronously,\n  // then immediately dispose of it. It'll be recreated again after the render is committed.\n  if (!refs.isMounted) {\n    // We want to forceUpdate in useEffect to support StrictMode.\n    // See: https://github.com/meteor/react-packages/issues/278\n    dispose(refs);\n  }\n\n  useEffect(() => {\n    // Let subsequent renders know we are mounted (render is comitted).\n    refs.isMounted = true;\n\n    // Render is committed. Since useTracker without deps always runs synchronously,\n    // forceUpdate and let the next render recreate the computation.\n    forceUpdate();\n\n    // stop the computation on unmount\n    return () => dispose(refs);\n  }, []);\n\n  return refs.trackerData;\n}\n\nconst useTrackerWithDeps: useTrackerSignature = (reactiveFn, deps: Array<any>, computationHandler) => {\n  const { current: refs } = useRef<TrackerRefs>({\n    reactiveFn,\n    isMounted: false,\n    trackerData: null\n  });\n  const forceUpdate = useForceUpdate();\n\n  // Always have up to date deps and computations in all contexts\n  refs.reactiveFn = reactiveFn;\n  refs.deps = deps;\n  if (computationHandler) {\n    refs.computationHandler = computationHandler;\n  }\n\n  // We are abusing useMemo a little bit, using it for it's deps\n  // compare, but not for it's memoization.\n  useMemo(() => {\n    // stop the old one.\n    dispose(refs);\n\n    track(refs, forceUpdate, tracked)\n\n    // Tracker creates side effect in render, which can be problematic in some cases, such as\n    // Suspense or concurrent rendering or if an error is thrown and handled by an error boundary.\n    // We still want synchronous rendering for a number of reasons (see readme). useTracker works\n    // around memory/resource leaks by setting a time out to automatically clean everything up,\n    // and watching a set of references to make sure everything is choreographed correctly.\n    if (!refs.isMounted) {\n      // Components yield to allow the DOM to update and the browser to paint before useEffect\n      // is run. In concurrent mode this can take quite a long time. 1000ms should be enough\n      // in most cases.\n      refs.disposeId = setTimeout(() => {\n        if (!refs.isMounted) {\n          dispose(refs);\n        }\n      }, 1000);\n    }\n  }, deps);\n\n  useEffect(() => {\n    refs.isMounted = true;\n\n    // Render is committed, clear the dispose timeout\n    clear(refs);\n\n    // If it took longer than 1000ms to get to useEffect, or a reactive update happened\n    // before useEffect, restart the computation and forceUpdate.\n    if (!refs.computation) {\n      // This also runs runReactiveFn\n      track(refs, forceUpdate, tracked);\n      forceUpdate();\n    }\n\n    // stop the computation on unmount\n    return () => dispose(refs);\n  }, []);\n\n  return refs.trackerData;\n}\n\nconst useTrackerClient: useTrackerSignature = (reactiveFn, deps = null, computationHandler) =>\n  (deps === null || deps === undefined || !Array.isArray(deps))\n    ? useTrackerNoDeps(reactiveFn, deps, computationHandler)\n    : useTrackerWithDeps(reactiveFn, deps, computationHandler);\n\nconst useTrackerServer: useTrackerSignature = (reactiveFn, deps = null, computationHandler) =>\n  Tracker.nonreactive(reactiveFn);\n\n// When rendering on the server, we don't want to use the Tracker.\n// We only do the first rendering on the server so we can get the data right away\nconst useTracker = Meteor.isServer\n  ? useTrackerServer\n  : useTrackerClient;\n\nconst useTrackerDev: useTrackerSignature = (reactiveFn, deps = null, computationHandler) => {\n  if (typeof reactiveFn !== 'function') {\n    console.warn(\n      'Warning: useTracker expected a function in it\\'s first argument '\n      + `(reactiveFn), but got type of ${typeof reactiveFn}.`\n    );\n  }\n  if (deps && !Array.isArray(deps)) {\n    console.warn(\n      'Warning: useTracker expected an array in it\\'s second argument '\n      + `(dependency), but got type of ${typeof deps}.`\n    );\n  }\n  if (computationHandler && typeof computationHandler !== 'function') {\n    console.warn(\n      'Warning: useTracker expected a function in it\\'s third argument'\n      + `(computationHandler), but got type of ${typeof computationHandler}.`\n    );\n  }\n  return useTracker(reactiveFn, deps, computationHandler);\n}\n\nexport default Meteor.isDevelopment\n  ? useTrackerDev\n  : useTracker;\n"],"sourceRoot":""},"sourceType":"module","hash":"51584c7374866255f3dd4974d35c6d74e1d5a1ef"}
